v1 = [1,2,4,5]
v2 = v1
print(v2)  # [1, 2, 4, 5]
v1.append(666)
print(v2)  # [1, 2, 4, 5, 666]

# 示例1
v1 = [1,2,3]
v2 = [4,5,6,v1]
v2[3].append(50)
print(v1)  # [1, 2, 3, 50]

# 实例2
v1 = [1,2,3]
v2 = [4,5,6,v1]
v2[3] = 90
print(v1)  # [1, 2, 3]

# 实例3
v1 = [1,2,3]
v2 = [4,5,6,v1]
v1[2] = 100
print(v2)  # [4, 5, 6, [1, 2, 100]]

# 实例4
v1 = [1,2,3]
v2 = [4,5,6,v1]
v1 = 100
print(v2)  # [4, 5, 6, [1, 2, 3]]

# 究其根源就是看是赋值还是修改内部的值
'''
python为了做内存优化，会将数字弄一个缓冲区，在这里面即使重新赋值
地址也不会改变，对数组不适用，对数字适用
'''
k1 = 3
k2 = 3
print(id(k1),id(k2))  # 2394238577008 2394238577008
k1 = -5
k2 = -5
print(id(k1),id(k2))  # 2612605773936 2612605773936
k1 = [1,2,3,4]
k2 = [1,2,3,4]
print(id(k1),id(k2))  # 2093069284032 2093072157120

'''

== 比较的是值是否相等
is 比较的是内尺寸地址是否相等
'''

v4 = 'alex'
v2 = v4
v4.upper()
print(v4,v2)  # alex alex
# 为什么还都是小写的呢，因为v4.upper会生成一个新的字符串，需要一个变量来接收

list1 = [1,2,3,4]
a = 1
print(id(a))
print(id(list[0]))  # 2500751681840   2500759881920

list2 = [1,2,3,4,5]  # 列表里面存储的是地址，地址指向数字的内存单元
list3 = []
for i in list2:
    list3.append(i)
print(id(list2[0]),id(list3[0]))  # 1902147365168 1902147365168

list2 = [1,2,3,4,5]
list3 = []
for i in list2:
    list3.append(str(i))  # 一旦对不可变数据做了修改，就会生成新的地址，就会改变
print(id(list2[0]),id(list3[0]))  # 1939037251888 1939041918768